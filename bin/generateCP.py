#!/usr/bin/env python3
import os
import collections
import sys

# CPBasicAttribute: attributes with basic types (int, float, char, bool, std::string and Engine::Point2D<int>)
def addBasicAttribute(line, attributesMap):
    splitLine = line.split()

    # 1st word will be the type of the attribute
    typeAttribute = splitLine[0]

    # 2nd word will be the name, removing final ';'
    variableName = splitLine[1]
    variableName = variableName.strip(';')

    attributesMap[variableName] = typeAttribute
    print '\t\t\tattribute detected: ' + variableName + ' with type: ' + typeAttribute
    return None

def getNewIDFromOrderMap(variableName, complexAttributesRelated):
    newID = 1
    if len(complexAttributesRelated.complexAttributesOrderMap) > 0:
        lastID = max(complexAttributesRelated.complexAttributesOrderMap, key = int)
        newID = lastID + 1

    return newID

# CPComplexAttribute: attributes with complex types (std::vector<T>, std::queue<T>, std::map<T, U> ; T|U = {int, float, char, bool, std::string, Engine::Point2D<int>})
def addComplexAttribute(line, complexAttributesRelated):
    splitLine = line.split(";")
    firstPart = splitLine[0]
    firstPartSplit = firstPart.split()

    firstPartLength = len(firstPartSplit)
    
    # 1st strings will the the type of the attribute, even if they are separated by spaces.
    typeAttribute = ''
    for i in range(0, firstPartLength - 1):
        typeAttribute += firstPartSplit[i]

    # 2nd word will be the name, removing final ';'
    variableName = firstPartSplit[firstPartLength - 1]
    variableName = variableName.strip(';')

    newID = getNewIDFromOrderMap(variableName, complexAttributesRelated)

    complexAttributesRelated.complexAttributesOrderMap[newID] = variableName
    complexAttributesRelated.complexAttributesFullType[newID] = typeAttribute

    print '\t\t\tattribute detected: ' + variableName + ' with type: ' + typeAttribute

    return None

def getAttributesFromClass(className, attributesMap, complexAttributesRelated):
    headerName = className + '.hxx'
    print '\t\tlooking for attributes of class: ' + className + ' in header: ' + headerName + '...'
    f = open(headerName, 'r')
    keyBasic = 'CPBasicAttribute'
    keyComplex = 'CPComplexAttribute'
    for line in f:
        splitLineDoubleSlash = line.split("//")
        splitLineSlashAsterisk = line.split("/*")
        if  splitLineDoubleSlash[0].replace(" ", "").replace("\t", "") == "" or \
            splitLineSlashAsterisk[0].replace(" ", "").replace("\t", "") == "": 
                continue

        if line.find(keyBasic) != -1:
            addBasicAttribute(line, attributesMap)
        elif line.find(keyComplex) != -1:
            addComplexAttribute(line, complexAttributesRelated)
        # parse base class, it must inherit from Agent
        elif line.find('class') != -1 and line.find(className) != -1 and line.find('public') != -1:
            splittedLine = line.rsplit()
            parentName = splittedLine[len(splittedLine) - 1]
            # remove namespace in case it exists
            parentNameWithoutNamespace = parentName
            indexSeparator = parentName.find('::')
            if (indexSeparator != -1):
                parentNameWithoutNamespace = parentName[indexSeparator + 2:]
            if parentNameWithoutNamespace != 'Agent':
                getAttributesFromClass(parentNameWithoutNamespace, attributesMap, complexAttributesRelated)
    f.close()
    return parentName

def includeVirtualMethodsHeaders(agentName, headerName):
    print '\tchecking if header: ' + headerName + ' for agent: ' + agentName + ' defines needed virtual methods...'
    # if this is not defined, we will add the four needed methods
    encodeAllAttributesName = 'encodeAllAttributesInString'
    f = open(headerName, 'r')
    for line in f:
        if line.find(encodeAllAttributesName) != -1:
            print '\tVirtual methods headers at "' + headerName + '" already correct.'
            return
    f.close()

    print '\t"' + headerName + '" does not contain virtual methods headers, adding them...'

    headerNameTmp = headerName + '_tmp'
    f = open(headerName, 'r')
    fTmp = open(headerNameTmp, 'w')

    insideClass = 0
    for line in f:
        if insideClass == 0:
            if line.find('class') != -1 and line.find(agentName) != -1:
                print 'accessing agent declaration: ' + agentName
                insideClass = 1
            fTmp.write(line)
        elif line.find('};') != -1:
            print 'end of agent declaration: ' + agentName
            insideClass = 0
            fTmp.write('\n')
            fTmp.write('\t///// Autogenerated code (do not modify): /////\n')
            fTmp.write('public:\n')
            fTmp.write('\t' + agentName + '(const std::string& agentID, const std::string& agentEncodedAttributes);\n')
            fTmp.write('\tstd::string encodeAllAttributesInString() const override;\n')
            fTmp.write('\t///////// End of autogenerated code ///////////\n')
            fTmp.write('\n')
            fTmp.write(line)
        else:
            fTmp.write(line)
    f.close()
    fTmp.close()
    os.rename(headerNameTmp, headerName)
    return None

def writeConstructor(f, agentName, parent, attributesMap, complexAttributesRelated):
    f.write(agentName + '::' + agentName + '(const std::string& agentID, const std::string& agentEncodedAttributes) : ' + parent + '(agentID)\n')
    f.write('{\n')
    f.write('\tstd::vector<std::string> tokens;\n')
    f.write('\tint lastUsedIndex = Engine::Agent::fillUpBaseAttributesFromEncodedAgent(agentEncodedAttributes, tokens);\n')
    f.write('\n')
    
    if len(attributesMap) > 0:
        for nameAttribute, typeAttribute in attributesMap.items():
            parserFunction = ''
            if typeAttribute == "int": parserFunction = "std::stoi"
            elif typeAttribute == "bool": parserFunction = "std::stoi"
            elif typeAttribute == "double": parserFunction = "std::stod"
            elif typeAttribute == "float": parserFunction = "std::stof"

            if typeAttribute == "int" or typeAttribute == "bool" or typeAttribute == "double" or typeAttribute == "float":
                f.write('\t' + nameAttribute + ' = ' + parserFunction + '(tokens[++lastUsedIndex]);\n')
            elif typeAttribute == "std::string":
                f.write('\t' + nameAttribute + ' = tokens[++lastUsedIndex];\n')
            elif typeAttribute == "Engine::Point2D<int>":
                f.write('\n')
                f.write('\tint ' + nameAttribute + 'X = std::stoi(tokens[++lastUsedIndex]);\n')
                f.write('\tint ' + nameAttribute + 'Y = std::stoi(tokens[++lastUsedIndex]);\n')
                f.write('\t' + nameAttribute + ' = Engine::Point2D<int>(' + nameAttribute + 'X, ' + nameAttribute + 'Y);\n')
                f.write('\n')

    f.write('\n')

    for variableID, variableName in complexAttributesRelated.complexAttributesOrderMap.items():
        variableShortType = complexAttributesRelated.complexAttributesShortType[variableID]
        typeOfElements = complexAttributesRelated.complexAttributesElementsType[variableID]

        if variableShortType == 'std::vector':
            f.write('\tstd::vector<std::string> tokens' + variableName + ' = getLineTokens(tokens[++lastUsedIndex], \' \');\n')
            f.write('\tfor (int i = 0; i < tokens' + variableName + '.size(); ++i)\n')
            f.write('\t{\n')
            
            if typeOfElements == "int": parserFunction = "std::stoi"
            elif typeOfElements == "bool": parserFunction = "std::stoi"
            elif typeOfElements == "double": parserFunction = "std::stod"
            elif typeOfElements == "float": parserFunction = "std::stof"

            if typeOfElements == "int" or typeOfElements == "bool" or typeOfElements == "double" or typeOfElements == "float":
                f.write('\t\t' + variableName + '.push_back(' + parserFunction + '(tokens' + variableName + '[i]));\n')
            elif typeOfElements == "std::string":
                f.write('\t\t' + variableName + '.push_back(tokens' + variableName + '[i]);\n')
            elif typeOfElements == "Engine::Point2D<int>":
                f.write('\t\tunsigned int commaPosition = tokens' + variableName + '[i].find_first_of(",");\n')
                f.write('\t\tint positionSplitX = std::stoi(tokens' + variableName + '[i].substr(0, commaPosition));\n')
                f.write('\t\tint positionSplitY = std::stoi(tokens' + variableName + '[i].substr(commaPosition + 1, tokens' + variableName + '[i].size() - commaPosition - 1));\n')
                f.write('\n')
                f.write('\t\t' + variableName + '.push_back(Engine::Point2D<int>(positionSplitX, positionSplitY));\n')
                
            f.write('\t}\n')
        
        f.write('\n')

    f.write('}\n')
    f.write('\n')
    return None

def getListOfSetterHeaders(agentName, complexAttributesRelated):
    complexAttributesOrderMap = complexAttributesRelated.complexAttributesOrderMap

    for variableID, variableName in complexAttributesRelated.complexAttributesOrderMap.items():
        print 'variableName "' + variableName + '" of type "' + complexAttributesRelated.complexAttributesFullType[variableID] + '"'

        typeOfElements = ''
        if complexAttributesRelated.complexAttributesFullType[variableID].find('<Engine::Point2D') != -1:
            typeOfElements = 'Engine::Point2D<int>'
        elif complexAttributesRelated.complexAttributesFullType[variableID].find('<int') != -1:
            typeOfElements = 'int'
        elif complexAttributesRelated.complexAttributesFullType[variableID].find('<float') != -1:
            typeOfElements = 'float'
        elif complexAttributesRelated.complexAttributesFullType[variableID].find('<bool') != -1:
            typeOfElements = 'bool'
        elif complexAttributesRelated.complexAttributesFullType[variableID].find('<char') != -1:
            typeOfElements = 'char'
        elif complexAttributesRelated.complexAttributesFullType[variableID].find('<std::string') != -1:
            typeOfElements = 'std::string'
        else:
            print 'No valid type for attribute "' + variableName + '" of type "' + complexAttributesRelated.complexAttributesFullType[variableID] + '"!'

        complexAttributesRelated.complexAttributesElementsType[variableID] = typeOfElements

        if complexAttributesRelated.complexAttributesFullType[variableID].find('std::vector') != -1:
            complexAttributesRelated.complexAttributesShortType[variableID] = 'std::vector'
        elif complexAttributesRelated.complexAttributesFullType[variableID].find('std::queue') != -1:
            complexAttributesRelated.complexAttributesShortType[variableID] = 'std::queue'
        elif complexAttributesRelated.complexAttributesFullType[variableID].find('std::map') != -1:
            valueType = ''
            if complexAttributesRelated.complexAttributesFullType[variableID].find(',Engine::Point2D<int>') != -1:
                valueType = 'Engine::Point2D<int>'
            elif complexAttributesRelated.complexAttributesFullType[variableID].find(',int') != -1:
                valueType = 'int'
            elif complexAttributesRelated.complexAttributesFullType[variableID].find(',float') != -1:
                valueType = 'float'
            elif complexAttributesRelated.complexAttributesFullType[variableID].find(',bool') != -1:
                valueType = 'bool'
            elif complexAttributesRelated.complexAttributesFullType[variableID].find(',char') != -1:
                valueType = 'char'
            elif complexAttributesRelated.complexAttributesFullType[variableID].find(',std::string') != -1:
                valueType = 'std::string'
            else:
                print 'No valid value type for map "' + variableName + '" of type "' + complexAttributesRelated.complexAttributesFullType[variableID] + '"!'

            complexAttributesRelated.complexAttributesShortType[variableID] = 'std::map'
            complexAttributesRelated.complexAttributesValueInMapType[variableID] = valueType

    return None

def writeEncoder(f, agentName, parent, attributesMap, complexAttributesRelated):
    f.write('std::string ' + agentName + '::encodeAllAttributesInString() const\n')
    f.write('{\n')
    f.write('\tstd::stringstream ss;\n')
    f.write('\n')
    f.write('\tss << Engine::Agent::encodeAllAttributesInString();\n')
    f.write('\n')

    if len(attributesMap) > 0:
        f.write('\tss <<\t')
        i = 1
        for nameAttribute, typeAttribute in attributesMap.items():
            if i != 1: f.write('\t\t')

            if typeAttribute == "Engine::Point2D<int>":
                f.write('\t' + nameAttribute + '.getX() << "|" << ' + nameAttribute + '.getY()')
            else:
                f.write('\t' + nameAttribute)
            f.write(' << "|"')

            if i < len(attributesMap): f.write(' <<\n')
            i += 1

        f.write(';\n')
        f.write('\n')
    
    for variableID, variableName in complexAttributesRelated.complexAttributesOrderMap.items():
        variableShortType = complexAttributesRelated.complexAttributesShortType[variableID]
        typeOfElements = complexAttributesRelated.complexAttributesElementsType[variableID]

        if variableShortType == 'std::vector':
            f.write('\tfor (int i = 0; i < ' + variableName + '.size(); ++i)\n')
            if typeOfElements == "Engine::Point2D<int>":
                f.write('\t\tss << ' + variableName + '[i].getX() << "," << ' + variableName + '[i].getY() << " ";\n')
            else:
                f.write('\t\tss << ' + variableName + '[i];\n')
        
        f.write('\tss << "|";\n')
        f.write('\n')

    f.write('\treturn ss.str();\n')

    f.write('}\n')
    f.write('\n')
    return None

def createCheckpointingCode(agentName, source, headerName, namespace, parent, attributesMap, complexAttributesRelated):
    print '\t\tcreating checkpointing file: checkpointingCode/' + agentName + '_checkpointing.cxx for agent: ' + agentName + ' in namespace: ' + namespace + ' with parent: ' + parent + ' from source: ' + source + ' and header: ' + headerName
    f = open('checkpointingCode/' + agentName + '_checkpointing.cxx', 'w')
    # header
    f.write('#include <' + agentName + '.hxx>\n')
    f.write('#include <Exception.hxx>\n')
    f.write('#include <iostream>\n')
    f.write('\n')
    if namespace != "":
        f.write('namespace ' + namespace + '\n')
        f.write('{\n')
        f.write('\n')

    if len(complexAttributesRelated.complexAttributesOrderMap) > 0:
        getListOfSetterHeaders(agentName, complexAttributesRelated)
    writeConstructor(f, agentName, parent, attributesMap, complexAttributesRelated)
    writeEncoder(f, agentName, parent, attributesMap, complexAttributesRelated)

    if namespace != "":
        f.write('} // namespace ' + namespace + '\n')
    f.write('\n')
    f.close()
    return None

def getAttributesFromWorldClass(worldName, worldAttributesMap):
    headerName = worldName + '.hxx'
    print '\t\tlooking for attributes of World class: ' + worldName + ' in header: ' + headerName + '...'
    f = open(headerName, 'r')
    keyBasic = 'CPBasicAttribute'
    for line in f:
        splitLineDoubleSlash = line.split("//")
        splitLineSlashAsterisk = line.split("/*")
        if  splitLineDoubleSlash[0].replace(" ", "").replace("\t", "") == "" or \
            splitLineSlashAsterisk[0].replace(" ", "").replace("\t", "") == "": 
                continue

        if line.find(keyBasic) != -1:
            addBasicAttribute(line, worldAttributesMap)

    return None

def writeSetterForModelWorldAttribute(f, nameAttribute, world, typeAttribute):
    f.write('void ' + world + '::set' + nameAttribute + '(const ' + typeAttribute + '& local' + nameAttribute + ')\n')
    f.write('{\n')
    f.write('\t' + nameAttribute + ' = local' + nameAttribute + ';\n')
    f.write('}\n')
    f.write('\n')
    return None

def writeSetCheckpointData(f, world, namespace, worldAttributesMap):
    f.write('void ' + world + '::setCheckpointData(const std::string& encodedWorldData)\n')
    f.write('{\n')
    f.write('\tstd::vector<std::string> tokens;\n')
    f.write('\tint lastUsedIndex = Engine::World::fillUpBaseAttributesFromEncodedWorld(encodedWorldData, tokens);\n')
    f.write('\n')
    
    if len(worldAttributesMap) > 0:
        for nameAttribute, typeAttribute in worldAttributesMap.items():
            parserFunction = ''
            if typeAttribute == "int": parserFunction = "std::stoi"
            elif typeAttribute == "bool": parserFunction = "std::stoi"
            elif typeAttribute == "double": parserFunction = "std::stod"
            elif typeAttribute == "float": parserFunction = "std::stof"

            if typeAttribute == "int" or typeAttribute == "bool" or typeAttribute == "double" or typeAttribute == "float":
                f.write('\t' + nameAttribute + ' = ' + parserFunction + '(tokens[++lastUsedIndex]);\n')
            elif typeAttribute == "std::string":
                f.write('\t' + nameAttribute + ' = tokens[index++];\n')
            elif typeAttribute == "Engine::Point2D<int>":
                f.write('\n')
                f.write('\tint ' + nameAttribute + 'X = std::stoi(tokens[++lastUsedIndex]);\n')
                f.write('\tint ' + nameAttribute + 'Y = std::stoi(tokens[++lastUsedIndex]);\n')
                f.write('\t' + nameAttribute + ' = Engine::Point2D<int>(' + nameAttribute + 'X, ' + nameAttribute + 'Y);\n')
                f.write('\n')

    f.write('}\n')
    f.write('\n')
    return None

def createWorldCheckpointingCode(world, namespaces, worldAttributesMap):
    namespace = namespaces[0]

    print '\t\tcreating checkpointing file: checkpointingCode/' + world + '_checkpointing.cxx for World: ' + world + ' in namespace: ' + namespace
    f = open('checkpointingCode/' + world + '_checkpointing.cxx', 'w')
    # header
    f.write('#include <' + world + '.hxx>\n')
    f.write('#include <Exception.hxx>\n')
    f.write('#include <iostream>\n')
    f.write('\n')
    if namespace != "":
        f.write('namespace ' + namespace + '\n')
        f.write('{\n')
        f.write('\n')

    writeSetCheckpointData(f, world, namespace, worldAttributesMap)

    if namespace != "":
        f.write('} // namespace ' + namespace + '\n')
    f.write('\n')
    f.close()
    return None

def includeWorldVirtualMethodsHeaders(worldName):
    headerName = worldName + '.hxx'

    print '\tchecking if header: ' + headerName + ' defines needed virtual methods...'
    # if this is not defined, we will add the four needed methods
    setCheckpointDataName = 'setCheckpointData'
    f = open(headerName, 'r')
    for line in f:
        if line.find(setCheckpointDataName) != -1:
            print '\tVirtual methods headers at "' + headerName + ' already correct.'
            return
    f.close()

    print '\t"' + headerName + '" does not contain virtual methods headers, adding them...'

    headerNameTmp = headerName + '_tmp'
    f = open(headerName, 'r')
    fTmp = open(headerNameTmp, 'w')
    
    insideClass = 0
    for line in f:
        if insideClass == 0:
            if line.find('class') != -1 and line.find(worldName) != -1:
                print 'accessing agent declaration: ' + worldName
                insideClass = 1
            fTmp.write(line)
        elif line.find('};') != -1:
            print 'end of World declaration: ' + worldName
            insideClass = 0
            fTmp.write('\n')
            fTmp.write('\t///// Autogenerated code (do not modify): /////\n')
            fTmp.write('public:\n')
            fTmp.write('\tvoid setCheckpointData(const std::string& encodedWorldData) override;\n')
            fTmp.write('\t///////// End of autogenerated code ///////////\n')
            fTmp.write('\n')
            fTmp.write(line)
        else:
            fTmp.write(line)
    f.close()
    fTmp.close()
    os.rename(headerNameTmp, headerName)
    return None

def writeCreateDecodePackage(f, listAgents, namespaces):
    f.write('Agent* CheckpointingFactory::decodeAndFillAgent(const std::string& type, const std::string& encodedAgent)\n')
    f.write('{\n')
    f.write('\tstd::string agentID = encodedAgent.substr(0, encodedAgent.find("|"));\n')
    f.write('\n')
    for i, agent in enumerate(listAgents):
        f.write('\tif (type.compare("' + agent + '") == 0)\n')
        f.write('\t\treturn new ' + namespaces[i] + "::" + agent + '(agentID, encodedAgent);\n')
    f.write('\n')

    f.write('\tthrow Engine::Exception(CreateStringStream("MpiFactory::decodeAndFillAgent - unknown agent type: " << type).str());\n')
    f.write('\treturn 0;\n')
    f.write('}\n')
    f.write('\n')
    return None

def writeSetWorldData(f, world, namespaces):
    f.write('void CheckpointingFactory::setWorldData(World* world, const std::string& encodedWorldData)\n')
    f.write('{\n')
    
    worldPointerStr = namespaces[0] + '::' + world + '*'  
    f.write('\t' + worldPointerStr + ' modelWorld = (' + worldPointerStr + ') world;\n')
    f.write('\tmodelWorld->setCheckpointData(encodedWorldData);\n')

    f.write('}\n')
    f.write('\n')
    return None

def createFactoryMethods(listAgents, world, factoryFile, namespaces):
    f = open(factoryFile, 'w')
    print '\tcreating checkpoiting factory: ' + factoryFile
    # headers
    f.write('#include <CheckpointingFactory.hxx>\n')
    f.write('#include <Exception.hxx>\n')
    f.write('#include <sstream>\n')
    f.write('\n')
    for i, agent in enumerate(listAgents):
        print '\t\tadding: ' + agent + ' to factory file: ' + factoryFile
        f.write('#include <' + agent + '.hxx>\n')
    f.write('\n')
    f.write('namespace Engine\n')
    f.write('{\n')
    f.write('\n')

    writeCreateDecodePackage(f, listAgents, namespaces)
    writeSetWorldData(f, world, namespaces)

    # close header & namespace
    f.write('} // namespace Engine\n')
    f.write('\n')
    f.close()
    return None

class ComplexAttributesRelated:
    
    def __init__(self):
        self.complexAttributesOrderMap = {}                      # <int: variableID, str: variableName>
        self.complexAttributesShortType = {}                     # <int: variableID, str: variableShortType>
        self.complexAttributesFullType = {}                      # <int: variableID, str: variableFullType>
        self.complexAttributesElementsType = {}                  # <int: variableID, str: variableElementsType>
        self.complexAttributesValueInMapType = {}                # <int: variableID, str: valuesInMapType>

def execute(target, agentsSource, world, env):

    print 'generating code for checkpointing...'
    listAgents = []
    listAttributesMaps = []
    namespaceAgents = env['namespaces']
    for i in range(1, len(agentsSource)):
        sourceName = str(agentsSource[i])
        headerName = sourceName.replace(".cxx", ".hxx")
        agentName = sourceName.replace(".cxx", "")

        listAgents += [agentName]
        
        attributesMap = {}
        complexAttributesRelated = ComplexAttributesRelated()

        parentName = getAttributesFromClass(listAgents[i - 1], attributesMap, complexAttributesRelated)
        includeVirtualMethodsHeaders(agentName, headerName)
        if not os.path.exists('checkpointingCode/'): os.makedirs('checkpointingCode/')
        createCheckpointingCode(listAgents[i - 1], sourceName, headerName, namespaceAgents[i - 1], parentName, attributesMap, complexAttributesRelated)
        listAttributesMaps.append(attributesMap)

    worldAttributesMap = {}
    getAttributesFromWorldClass(world, worldAttributesMap)
    includeWorldVirtualMethodsHeaders(world)
    createWorldCheckpointingCode(world, namespaceAgents, worldAttributesMap)

    createFactoryMethods(listAgents, world, str(target[0]), namespaceAgents)

    print 'Checkpointing code auto-generation DONE!'
    return None